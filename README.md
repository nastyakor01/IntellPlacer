# Требования к входным данным: 

<code> 1. Требования к фото
* Фото делается на камеру, находящуюся на расстоянии 45 см от пола (допустима погрешность в 5 см), камера смотрит перпендикулярно естественной поверхности 
* Разрешение фото: 4032 x 3024
* Фон на фотографии должен быть целиком заполнен белым листом бумаги
* Освещение должно быть равномерным
2. Требования к многоугольнику
* Многоугольник должен быть выпуклым
* Многоугольник задается массивом координат вершин на естественной плоскости
3. Требования к расположению объектов внутри многоугольника
* Предметы не могут перекрывать друг друга
* Один предмет не может находиться на фотографии больше одного раза
</code>  

# Требования к выходным данным:
Программа выводит одну строку:
* "Да" --- если предметы со входных изображений можно разместить в том же положении, что и на шаблонах, на поверхности с учетом всех требований из пункта 3 так, чтобы они находились целиком внутри многоугольника, либо задевали его границу.
* "Нет" --- если предметы со входных изображений нельзя разместить в том же положении, что и на шаблонах, на поверхности с учетом всех требований из пункта 3 так, чтобы они находились целиком внутри многоугольника, либо задевали его границу.

# Фотографии предметов:
![image](https://user-images.githubusercontent.com/55063415/132926718-31eb092c-6b09-42ff-ad45-4f06e41f09b6.png)
![image](https://user-images.githubusercontent.com/55063415/132926729-9505fac4-bf1e-42aa-8900-2fd45cc2d498.png)
![image](https://user-images.githubusercontent.com/55063415/132926755-37429755-686d-4b22-bc77-027dcd249aab.png)
![image](https://user-images.githubusercontent.com/55063415/132926764-ebb54b5c-55bd-4e86-884b-ccdc6ef2414f.png)
![image](https://user-images.githubusercontent.com/55063415/132926778-4a92046c-94f4-49e0-85e1-98d8ee3d0062.png)
![image](https://user-images.githubusercontent.com/55063415/132926788-11f4ff92-584f-447b-a82f-d2bfad6aca99.png)
![image](https://user-images.githubusercontent.com/55063415/132926793-04bc56d9-483c-41a6-bd39-6e02cfa70535.png)
![image](https://user-images.githubusercontent.com/55063415/132926797-f9e93c62-02de-4b46-b06c-aafb038ec837.png)
![image](https://user-images.githubusercontent.com/55063415/132926888-f6147e6f-dcaa-403c-ba19-743636ab91a9.png)
![image](https://user-images.githubusercontent.com/55063415/132953629-7733353f-fb95-4110-87f5-f907574a2b83.png)


# Фотография поверхности:
![image](https://user-images.githubusercontent.com/55063415/132927007-155c7dcf-3b5d-4b81-b49a-88938cdf7f6d.png)

# Алгоритм решения:


## Подготовительная работа
<code>
1. Зафиксируем некоторое пороговое значение для алгорита Харриса-Лапласса. <br>


2. Производим следущие действия с каждым из шаблонов: <br>


* Используем алгоритм Canny для нахождения границ объекта шаблона <br>


* Для найденных границ используем морфологические преобразования binary_closing чтобы получить четкие замкнутые границы. <br>


* С помощью преобразования Харриса-Лапласса с пороговым значением, зафиксированным на шаге 1, находим особые точки шаблона (будем использовать меру Ферстнера). <br>


* Опишем объект шаблона приближающим его прямоугольником. <br>


</code>


## Распознавание объектов на входном фото

<code>

1. Используем алгоритм Canny для нахождения границ объектов на входном изображении. <br>


2. Для найденных границ используем морфологические преобразования binary_closing чтобы получить четкие замкнутые границы. <br>  


3. Заводим некоторый адаптивнй радиус. В идеале это радиус самого маленького объекта на входном изображении, но как его найти я не придумала.<br>


4. Применяем к полученной в пункте 2 карте границ алгоритм Харриса-Лапласса для адаптивного радиуса из пункта 3 порогового значения, выбранного во время подготовительной работы. Будем использовать меру Ферстнера. МЫ получили карту особых точек на входном ихображении. <br>


5. Получим дескрипторы особых точек с помощью SIFT.<br>


6. Заводим пустое множество и выполняем следующие действия в цикле для каждой из полученных карт особых точек: <br>


* Двигаемся по входному изображению квадратами со стороной  равной диаметру самого большого объекта на изображении (как его искать тоже не ясно). Шаг сдвига равен половине стороны квадрата.


* Сравниваем особые точки, попавшие в квадрат, с особыми точками шаблонов по их дескрипторам. Если нашли похожий объект, сохраняем в множество его шаблон. Нужно определить что здесь такое похожий объект -- пока непонятно как.

</code>

## Проверка того, попадают ли обекты в многоугольник
Мы получили множество шаблонов, соответствующих объектам со входной фотографии, причем для каждого шаблона получен прямоугольник, описыва.щий находящийся на нем объект.
<code>
1. Остортируем это множество в порядке убывания диаметров прямоугольников. <br>
2. Вычислим диаметр входного многоугольника.<br>
3. Идем циклом по элементам множества:
* Если диаметр прямоугольника, описанного вокруг предмета шаблона больше диаметра входрного многоугольника, возвращаем "Нет".
* Строим разность по Минковскому прямоугольника и многоугольника. Если она пустая, возвращаем "Нет". Если непустая, "вырезаем" прямоугольник из многоугольника и переходим к следующей итерации цикла.
4. Возвращаем "Да".
</code>

# Улучшения

Нужно научиться решать задачу в случае, когда предметы разрешено вращать внутри многоугольника. <br>
Стоит придумать какой-то алгоритм заплнения многоугольника, кроме жадного.<br>
Возможно, описывать предметы не прямоугольниками, а треугольниками и решать задачу с помощью триангуляции входного многоугольника.<br>
Можно добавить дополнительную карту особых точек(с мерой Харриса или другоим пороговым значением), чтобы сматчилось больше предметов.<br>
Нужно обязательно придумать критерий "похожести предметов" при сравнении по особым точкам.<br>